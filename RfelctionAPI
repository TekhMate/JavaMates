import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import ma.glasnost.orika.MappingContext;

public class WBAuditService {

    private WBAuditRepository wbAuditRepository;
    private PickListLoaderCacheService cacheService;

    Class<?> intType = Integer.TYPE;

    public void saveJacksonAuditLogs(AuditAsynchronousModel auditAsyncModel){
        List<AuditFields> wholeAuditChanges = new ArrayList<>();
        JsonFactory factory = new JsonFactory();

        ObjectMapper mapper = formObjectMapper();
        JsonNode rootNode = null;
        try {
            rootNode = mapper.readTree(auditAsyncModel.getRequestJsonPayload());
            log.info("extracting Audit changes from request payload for appGroup:"+auditAsyncModel.getAppGroup()+" and apMasterId:"+auditAsyncModel.getAppMasterId());
            extractNodes(rootNode, mapper, wholeAuditChanges);
            log.info("extracted '"+wholeAuditChanges.size()+"' Audit changes for appGroup:"+auditAsyncModel.getAppGroup()+" and apMasterId:"+auditAsyncModel.getAppMasterId());

            if (!wholeAuditChanges.isEmpty()) {
                MappingContext context = new MappingContext.Factory().getContext();
                context.setProperty("appGroup", auditAsyncModel.getAppGroup());
                context.setProperty("appMasterId", auditAsyncModel.getAppMasterId());
                context.setProperty("updatedBy", auditAsyncModel.getUpdatedBy());

                List<AuditLogsEntity> auditLogEntities = AuditMapperService.mapperFacade().mapAsList(wholeAuditChanges, AuditLogsEntity.class, context);
                formatAuditLogs(auditLogEntities, auditAsyncModel.getAppGroup());
                log.info("formatted whole log entities: "+WbJsonUtils.toJson(auditLogEntities));
                wbAuditRepository.saveAuditLogs(auditLogEntities);
                log.info("saved Audit changes to db for appGroup:"+auditAsyncModel.getAppGroup()+" and apMasterId:"+auditAsyncModel.getAppMasterId());
            } else {
                log.warn("No audit changes found for appGroup:"+auditAsyncModel.getAppGroup()+" and apMasterId:"+auditAsyncModel.getAppMasterId());
            }

        } catch (IOException e) {
            log.error("error occurred while parsing Jackson Nodes, due to: "+e.getMessage());
        }
    }

    public List<AuditFields> extractNodes(JsonNode jsonNode, ObjectMapper mapper,
                                          List<AuditFields> wholeAuditChanges) {

        if (jsonNode == null)
            return null;

        try {
            Iterator<Map.Entry<String, JsonNode>> jsonFields = jsonNode.fields();
            if (jsonFields != null) {
                while (jsonFields.hasNext()) {
                    Map.Entry<String, JsonNode> field = jsonFields.next();
                    if (field != null) {
                        extractPropertyValueChanges(field,mapper, wholeAuditChanges);
                    }
                }
            }
        } catch (Exception e) {
            log.error("error occurred while extracting Json Nodes from payload:"+RCAFUtil.getErrorMessage(e));
        }
        return wholeAuditChanges;
    }

    public void extractPropertyValueChanges(Map.Entry<String, JsonNode> field, ObjectMapper mapper,
                                            List<AuditFields> wholeAuditChanges){
        final JsonNode fieldValue = field.getValue();
        if (StringUtils.equals(WBAuditConstants.AUD_PROPS_NAME, field.getKey())
                && fieldValue != null) {
            try {
                TypeReference<List<AuditFields>> typeRef = new TypeReference<List<AuditFields>>() {};
                List<AuditFields> auditLogs = mapper.readValue(String.valueOf(fieldValue), typeRef);

                //propertyValueChanges - can be null if no changes in respective Model/Node/Obj
                if (auditLogs != null)
                    wholeAuditChanges.addAll(auditLogs);
            } catch (Exception e) {
                log.error("error occurred while parsing propertyValueChanges: "+RCAFUtil.getErrorMessage(e));
            }
        }

        else

        if (fieldValue != null && fieldValue.isContainerNode()) {//object or Array
            try {
                if (fieldValue.isArray()) {
                    Iterator<JsonNode> elementNodes = fieldValue.elements();
                    while (elementNodes.hasNext()) {
                        extractNodes(elementNodes.next(), mapper, wholeAuditChanges); // RECURSIVE CALL
                    }
                } else {
                    extractNodes(fieldValue, mapper, wholeAuditChanges); // RECURSIVE CALL
                }
            } catch (Exception e) {
                log.error("error occurred while accessing containerNode:"+e.getMessage());
            }
        }
    }

    //handles picklist fields and Date fields
    public List<AuditLogsEntity> formatAuditLogs(List<AuditLogsEntity> auditLogsEntities, String appGroup){
        List<AuditMetaEntity> auditMetaEntities = fetchAuditMetaData(appGroup);
        log.info("formatting audit logs");
        Iterator iterator = auditLogsEntities.iterator();
        while (iterator.hasNext()) {
            AuditLogsEntity logEntity = (AuditLogsEntity)iterator.next();
            for (AuditMetaEntity metaEntity: auditMetaEntities) {
                if (StringUtils.equals(logEntity.getFieldName(), metaEntity.getJsonFieldName())
                        && StringUtils.equals(appGroup, metaEntity.getAppGroup())) {
                    logEntity.setAppTabName(metaEntity.getAppTabName());//IMP
                    if (StringUtils.isNotEmpty(logEntity.getTabSection())){
                        logEntity.setFieldName(logEntity.getTabSection().concat("-").concat(metaEntity.getFieldDisplayName()));
                    } else {
                        logEntity.setFieldName(metaEntity.getFieldDisplayName());
                    }
                    if (WBAuditConstants.DATE_OBJ_TYPE.equalsIgnoreCase(metaEntity.getFieldDataType())) {
                        logEntity.setOldValue(covertLongDateToString(logEntity.getOldValue()));
                        logEntity.setNewValue(covertLongDateToString(logEntity.getNewValue()));
                    } else if (StringUtils.isNotEmpty(metaEntity.getPickListCode())) {
                        logEntity.setOldValue(fetchDropDownValue(logEntity.getOldValue(), metaEntity.getPickListCode()));
                        logEntity.setNewValue(fetchDropDownValue(logEntity.getNewValue(), metaEntity.getPickListCode()));
                    }
                    break;
                }
            }
        }
        return auditLogsEntities;
    }

    public List<AuditMetaEntity> fetchAuditMetaData(String appGroup){
        log.info("fetching audit Meta for "+appGroup);
        Map<String, Object> params = new HashMap<>();
        params.put("appGroup", appGroup);

        return wbAuditRepository.findByQuery("fetchAuditMetaDataByAppGroup", params, AuditMetaEntity.class);
    }

    //Old java Obj based approach
    public void saveAuditLogs(AuditAsynchronousModel auditAsyncModel){
        Class originClassType = null;
        try {
            originClassType = Class.forName(auditAsyncModel.getOriginClassType());
        } catch (ClassNotFoundException e) {
            log.error("origin class fully qualified name required: "+e.getMessage());
            return;
        }
        Object originObject = WbJsonUtils.parseJson(auditAsyncModel.getRequestJsonPayload(), originClassType);

        //setting external params to MappingContext which are not available in source class
        MappingContext context = new MappingContext.Factory().getContext();
        context.setProperty("appGroup", auditAsyncModel.getAppGroup());
        context.setProperty("appMasterId", auditAsyncModel.getAppMasterId());
        context.setProperty("updatedBy", auditAsyncModel.getUpdatedBy());

        log.info("extracting Audit changes from request payload for appGroup:"+auditAsyncModel.getAppGroup()+" and apMasterId:"+auditAsyncModel.getAppMasterId());
        List<AuditFields> auditFieldsList = extractAuditChangesFromPayLoad(originObject);
        log.info(WbJsonUtils.toJson(auditFieldsList));
        List<AuditLogsEntity> auditLogEntities = AuditMapperService.mapperFacade().mapAsList(auditFieldsList, AuditLogsEntity.class, context);
        wbAuditRepository.saveAuditLogs(auditLogEntities);
        log.info("saved Audit changes to db for appGroup:"+auditAsyncModel.getAppGroup()+" and apMasterId:"+auditAsyncModel.getAppMasterId());
    }

    public List<AuditLogsEntity> fetchAuditLogs(BigDecimal appMasterId, String appGroup, String appTabName){

        log.info("fetching audit logs for "+appGroup+", masterId: "+appMasterId);
        Map<String, Object> params = new HashMap<>();
        params.put("appMasterId", appMasterId);
        params.put("appGroup", appGroup);
        params.put("appTabName", appTabName);

        return wbAuditRepository.findByQuery("fetchAuditLogsByAppMaster", params, AuditLogsEntity.class);
    }

    public List<AuditFields> extractAuditChangesFromPayLoad(Object originObj){
        List<AuditFields> wholeAuditChanges = new ArrayList<>();

        Class<?> reflectionClass = originObj.getClass();

        Field auditChanges = null;
        try {
            auditChanges = reflectionClass.getSuperclass().getDeclaredField("propertyValueChanges");
        } catch (NoSuchFieldException exception) {
            log.error("TabName not available under :" + reflectionClass,exception.getMessage());
        }
        if (auditChanges != null) {
                auditChanges.setAccessible(true);
            try {
                if (auditChanges.get(originObj) instanceof List) {
                    List<AuditFields> auditChangesList = (List<AuditFields>) auditChanges.get(originObj);
                    if (CollectionUtils.isNotEmpty(auditChangesList)) {
                        log.info(reflectionClass.getSimpleName() + " contains " + auditChangesList.size() + " no.of audit changes");
                        wholeAuditChanges.addAll(auditChangesList);
                    }
                }
            } catch (IllegalAccessException e) {
                log.error("error occurred while reading appTabName ", e);
            }
        }

        Field[] originObjFields = reflectionClass.getDeclaredFields();
        for(Field field : originObjFields) {
            constructFieldAuditData(originObj, field, wholeAuditChanges, "NA");
        }
        log.info("no.of audit changes found in entire RCAF form - "+wholeAuditChanges.size());
        log.info("audit changes Json: "+WbJsonUtils.toJson(wholeAuditChanges));
        return wholeAuditChanges;
    }

    //filters the fields which contains audit changes
    public void constructFieldAuditData(Object originObj, Field field,
                                        List<AuditFields> wholeAuditChanges, String tabName){
        field.setAccessible(true);

        try {
            if (!field.getType().isAssignableFrom(String.class)
                    && !field.getType().isAssignableFrom(Boolean.class)
                    && !field.getType().isAssignableFrom(intType)
                    && !field.getType().isAssignableFrom(BigDecimal.class)
                    && !field.getType().isAssignableFrom(Date.class)
                    && !field.getType().isAssignableFrom(Long.class)) {
                log.info(field.getName() + ", fieldType: "+field.getType());

                Object innerObj = field.get(originObj);
                if (innerObj instanceof List){
                    for (Object innerObjListIndexObj: (List)innerObj){
                        constructAuditList(innerObjListIndexObj, wholeAuditChanges, tabName);
                    }
                } else {
                    constructAuditList(innerObj, wholeAuditChanges, tabName);
                }
            }
        } catch (IllegalAccessException e) {
            log.error("error occurred while reading audit data", e.getCause());
        }
    }

    //extracts actual audit changes and adds to global list
    public void constructAuditList(Object innerObj, List<AuditFields> wholeAuditChanges, String tabName){
        if (innerObj == null)
            return;

        try {
            if (innerObj.getClass().isAnnotationPresent(WBAudit.class)) {
                Annotation annotation = innerObj.getClass().getAnnotation(WBAudit.class);
                WBAudit wbAudit = (WBAudit) annotation;
                tabName = wbAudit.tabName();
            }
        } catch (Exception e) {
            log.error("error occurred while reading annotated value: ",e);
        }

        try {
            Field innerObjAuditChanges = innerObj.getClass().getSuperclass().getDeclaredField("propertyValueChanges");
            if (innerObjAuditChanges != null) {
                innerObjAuditChanges.setAccessible(true);

                if (innerObjAuditChanges.get(innerObj) instanceof List) {
                    List<AuditFields> auditChangesList = (List<AuditFields>) innerObjAuditChanges.get(innerObj);
                    if (CollectionUtils.isNotEmpty(auditChangesList)) {
                        log.info(innerObj.getClass().getSimpleName() + " contains " + auditChangesList.size() + " no.of audit changes");
                        for (AuditFields eachAuditObj : auditChangesList) {
                            eachAuditObj.setAppTabName(tabName);
                            log.info(eachAuditObj.toString());
                            wholeAuditChanges.add(eachAuditObj);
                        }
                    }
                }
            }
            Field[] originObjFields = innerObj.getClass().getDeclaredFields();
            for (Field field : originObjFields) {
                constructFieldAuditData(innerObj, field, wholeAuditChanges, tabName);
            }
        } catch (NoSuchFieldException exception) {
            log.error("capturing audit data not applicable for :" + innerObj.getClass(),exception.getMessage());
        } catch (Exception e) {
            log.error("error occurred while reading inner audit data", e);
        }
    }

    public String fetchDropDownValue(String codeValue, String idCode) {
        if (codeValue == null || idCode ==null)
            return null;

        StringBuffer pickListDisplayName = new StringBuffer("");
        try {
            String[] codeValArray = codeValue.split(",");
            for (String eachCodeVal: codeValArray){
                if (!pickListDisplayName.toString().equals(""))
                    pickListDisplayName.append(",");

                pickListDisplayName.append(fetchDescByIdCodeAndVal(eachCodeVal, idCode));
            }
        } catch (Exception e) {
            log.error("error occurred while splitting picklist codeValues"+e);
        }
        return pickListDisplayName.toString();
    }

    public String fetchDescByIdCodeAndVal(String codeValue, String idCode) {
        if (idCode != null && codeValue != null) {
            String cacheKey = RCAFUtil.fetchKeyValue(idCode);
            Map<String, Map<String, List<Code>>> cacheMap = cacheService.loadRcafCache();

            List<Code> codesList = cacheMap.get("rcaf-picklist").get(cacheKey);

            if (CollectionUtils.isNotEmpty(codesList)) {
                for (Code code : codesList) {
                    if (code != null && code.getIdCode().equalsIgnoreCase(idCode)
                            && code.getCodeValue().equalsIgnoreCase(codeValue)) {
                        return code.getShortDescription();
                    }
                }
            }
        }
        return null;
    }

    public static String covertLongDateToString(String strLongDate) {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat(WBAuditConstants.UI_DATE_FORMAT);
            return sdf.format(Long.parseLong(strLongDate));
        } catch (NumberFormatException e) {
            log.error("error occurred while parsing long date to string date", e);
        }
        return null;
    }

    public static String convertToDisplayFormat(Date sourceDate, String toFormat){
        try {
            DateFormat toUIFormat = new SimpleDateFormat(toFormat);
            return toUIFormat.format(sourceDate);
        } catch (Exception e) {
            log.error("error occurred while parsing date to string date", e);
        }
        return null;
    }

    public ObjectMapper formObjectMapper(){
        ObjectMapper mapper = null;
        try {
            WbJsonUtils wbJsonUtils = new WbJsonUtils();
            Field field = wbJsonUtils.getClass().getDeclaredField("objectMapper");
            field.setAccessible(true);
            mapper = (ObjectMapper)field.get(wbJsonUtils);
        } catch (NoSuchFieldException e) {
            log.error("error occurred while fetching ObjectMapper from WbJsonUtils: "+e.getMessage());
        } catch (IllegalAccessException e) {
            log.error("error occurred while fetching ObjectMapper from WbJsonUtils: "+e.getMessage());
        }
        return mapper;
    }
}
